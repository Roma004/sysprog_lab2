# About

It's a study project in which I emulate virtual PCIe device with userspace programm on Host and interract with it on Linux quest. There is no warranty or purpose to be usefull for anyone except my groupmates. However, If you are in search of something like that, Welcome!

Though, other explanations in Russian...

# Задание:
Необходимо спроектировать и реализовать на языке C драйвер PCIe-устройства для ОС Linux.
Примечания:
1. Разработка и отладка ведётся с использованием виртуальной машины QEMU;
2. Разрабатываемый драйвер является драйвером символьного устройства;
3. Для разработки, отладки и демонстрации, в качестве памяти виртуального PCIe-устройства
используется внешний бинарный файл;
4. Для разработки, отладки и демонстрации требуется разработать программу (можно использовать
любой язык программирования), который со стороны хостовой ОС читает и пишет в бинарный файл,
тем самым эмулирует работу устройства.
5. Необходимо разработать и описать механизм управления устройством. За основу желательно взять
открытые стандарты и реальные устройства такого типа.
6. Необходимо предусмотреть возможность конфигурирования через sysfs.

## Индивидуальное задание:
"Запоминающее" устройство - устройство, позволяющее записать и прочитать в произвольное
место фиксированного буфера любой по длине массив информации

# Разяснения

## Сборка QEMU

Мне пришлось поработать с исходным модулем для QEMU, предоставленным нашим
вариантом задания, что вылилось в полную его переделку.

Список изменений:
- Возможность маппинга на файл не только bar2, но и bar0 регистра.
  В целом, можно мапить любой, но я в коде указал возможность только этих двух,
  так как маппинг bar1 на файл в силу неизвестных обстоятельств вводит qemu в
  вечный цикл. bar3-bar6 можно зарегистрировать, но если добавить в коде эти
  настройки (см qemu/hw/misc/lab2-testdev.c коментарии с пометкой NOTE)
- Возможность отослать MSI прерывание гостевой ОС через сокет

Собственно, всё затевалось ради второго пункта, так как без него лабу нормально
выполнить невозможно.

Идея: хост, при завершении транзакции чтения/записи генерирует прерывание
посредством записи `I` в сокет, открытый на хосте/порте согласно настройкам.
Без этого в драйвере пришлось бы организовыавть ожидание установки бита в цикле,
что должно забить всё процессорное время.

Второе улучшение: возможность маппить несколько регистров на разные файлы.
Вообще, обычно конфигурационные регистры лежат в bar0, а пространство передачи
данных - в bar2. (Можно вообще ещё пространство чтения в bar2, а пространство
записи - в bar3, но не важно). В bar1 обычно msi-X таблца, но тут без неё можно.

В общем, второе - просто небольшое улучшение относительно исходного варианта.

Для применения изменений:
```
git clone <qemu репозиторий>
cd qemu
git apply /path/to/lab2_testdev.patch

cd build
make
```

В этом репозитории есть Makefile для загрузки правильной qemu. (make qemu-run).
Перепроверьте его перед запуском, указжите свои пути для файлов

## Касательно остального кода

* pcie_device -- прога со стороны хоста (make dev из директории)
* pcie -- модуль ядра (make - собрать, make add - установить модуль, make rm - убрать модуль, make stt -- лог модуля из dmesg)
* header_gen -- можете сюда не смотерть, это мои файлы для генерации шаблонных функций чтения/записи в bar регистры.
